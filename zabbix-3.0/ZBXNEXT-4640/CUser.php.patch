20c20
< 
---
> //support KEYCLOAK
26a27,33
> require_once realpath(dirname(__FILE__).'/../../../..').'/vendor/autoload.php';
> use fkooman\OAuth\Client\Http\CurlHttpClient;
> use fkooman\OAuth\Client\OAuthClient4zk;
> use fkooman\OAuth\Client\Provider;
> use fkooman\OAuth\Client\AccessToken;
> 
> 
1033,1048c1040,1072
< 		$sessionId = self::$userData['sessionid'];
< 
< 		$session = DBfetch(DBselect(
< 			'SELECT s.userid'.
< 			' FROM sessions s'.
< 			' WHERE s.sessionid='.zbx_dbstr($sessionId).
< 				' AND s.status='.ZBX_SESSION_ACTIVE
< 		));
< 
< 		if (!$session) {
< 			self::exception(ZBX_API_ERROR_PARAMETERS, _('Cannot logout.'));
< 		}
< 
< 		DBexecute('DELETE FROM sessions WHERE status='.ZBX_SESSION_PASSIVE.' AND userid='.zbx_dbstr($session['userid']));
< 		DBexecute('UPDATE sessions SET status='.ZBX_SESSION_PASSIVE.' WHERE sessionid='.zbx_dbstr($sessionId));
< 
---
>         $sessionId = self::$userData['sessionid'];
>         $config = select_config();
>         if ($config['authentication_type'] == ZBX_AUTH_KEYCLOAK){
>             if (PHP_SESSION_ACTIVE !== session_status()) {
>                 session_start();
>             }
>             $client = CWebUser::getOAuth2client();
>             //DELETE SESSION on keycloak side.
>             $client->logout($sessionId);
>             //DELETE TOKEN on zabbix DB side.
>             DBexecute('DELETE FROM access_tokens where zbx_session_id='.zbx_dbstr($sessionid));
>             //DELETE ZBX_DEFAULT_SESSION on zabbix DB side.
>             DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionId));
>             //CLEAN  PHP_SESSION Array
>             // $_SESSION = array();
>             session_write_close();
>             // CSession::destroy();
> 
>         }else{
>             $session = DBfetch(DBselect(
>                 'SELECT s.userid'.
>                 ' FROM sessions s'.
>                 ' WHERE s.sessionid='.zbx_dbstr($sessionId).
>                     ' AND s.status='.ZBX_SESSION_ACTIVE
>             ));
> 
>             if (!$session) {
>                 self::exception(ZBX_API_ERROR_PARAMETERS, _('Cannot logout.'));
>             }
> 
>             DBexecute('DELETE FROM sessions WHERE status='.ZBX_SESSION_PASSIVE.' AND userid='.zbx_dbstr($session['userid']));
>             DBexecute('UPDATE sessions SET status='.ZBX_SESSION_PASSIVE.' WHERE sessionid='.zbx_dbstr($sessionId));
>         }
1053c1077
< 	 * Login user.
---
> 	 * keycloak Login user.
1055,1057d1078
< 	 * @param array $user
< 	 * @param array $user['user']		User alias
< 	 * @param array $user['password']	User password
1059,1153c1080,1111
< 	 * @return string					session id
< 	 */
< 	public function login($user) {
< 		$name = $user['user'];
< 		$password = md5($user['password']);
< 
< 		$userInfo = DBfetch(DBselect(
< 			'SELECT u.userid,u.attempt_failed,u.attempt_clock,u.attempt_ip'.
< 			' FROM users u'.
< 			' WHERE u.alias='.zbx_dbstr($name)
< 		));
< 		if (!$userInfo) {
< 			self::exception(ZBX_API_ERROR_PARAMETERS, _('Login name or password is incorrect.'));
< 		}
< 
< 		// check if user is blocked
< 		if ($userInfo['attempt_failed'] >= ZBX_LOGIN_ATTEMPTS) {
< 			if ((time() - $userInfo['attempt_clock']) < ZBX_LOGIN_BLOCK) {
< 				self::exception(ZBX_API_ERROR_PARAMETERS, _s('Account is blocked for %s seconds', (ZBX_LOGIN_BLOCK - (time() - $userInfo['attempt_clock']))));
< 			}
< 
< 			DBexecute('UPDATE users SET attempt_clock='.time().' WHERE alias='.zbx_dbstr($name));
< 		}
< 
< 		// check system permissions
< 		if (!check_perm2system($userInfo['userid'])) {
< 			self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
< 		}
< 
< 		$dbAccess = DBfetch(DBselect(
< 			'SELECT MAX(g.gui_access) AS gui_access'.
< 			' FROM usrgrp g,users_groups ug'.
< 			' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
< 				' AND g.usrgrpid=ug.usrgrpid'
< 		));
< 
< 		if (zbx_empty($dbAccess['gui_access'])) {
< 			$guiAccess = GROUP_GUI_ACCESS_SYSTEM;
< 		}
< 		else {
< 			$guiAccess = $dbAccess['gui_access'];
< 		}
< 
< 		$config = select_config();
< 		$authType = $config['authentication_type'];
< 
< 		switch ($guiAccess) {
< 			case GROUP_GUI_ACCESS_INTERNAL:
< 				$authType = ($authType == ZBX_AUTH_HTTP) ? ZBX_AUTH_HTTP : ZBX_AUTH_INTERNAL;
< 				break;
< 			case GROUP_GUI_ACCESS_DISABLED:
< 				/* fall through */
< 			case GROUP_GUI_ACCESS_SYSTEM:
< 				/* fall through */
< 		}
< 
< 		if ($authType == ZBX_AUTH_HTTP) {
< 			// if PHP_AUTH_USER is not set, it means that HTTP authentication is not enabled
< 			if (!isset($_SERVER['PHP_AUTH_USER'])) {
< 				self::exception(ZBX_API_ERROR_PARAMETERS, _('Cannot login.'));
< 			}
< 			// check if the user name used when calling the API matches the one used for HTTP authentication
< 			elseif ($name !== $_SERVER['PHP_AUTH_USER']) {
< 				self::exception(ZBX_API_ERROR_PARAMETERS,
< 					_s('Login name "%1$s" does not match the name "%2$s" used to pass HTTP authentication.',
< 						$name, $_SERVER['PHP_AUTH_USER']
< 					)
< 				);
< 			}
< 		}
< 
< 		try {
< 			switch ($authType) {
< 				case ZBX_AUTH_LDAP:
< 					$this->ldapLogin($user);
< 					break;
< 				case ZBX_AUTH_INTERNAL:
< 					$this->dbLogin($user);
< 					break;
< 				case ZBX_AUTH_HTTP:
< 			}
< 		}
< 		catch (APIException $e) {
< 			$ip = (isset($_SERVER['HTTP_X_FORWARDED_FOR']) && !empty($_SERVER['HTTP_X_FORWARDED_FOR']))
< 					? $_SERVER['HTTP_X_FORWARDED_FOR']
< 					: $_SERVER['REMOTE_ADDR'];
< 			$userInfo['attempt_failed']++;
< 
< 			DBexecute(
< 				'UPDATE users'.
< 				' SET attempt_failed='.zbx_dbstr($userInfo['attempt_failed']).','.
< 					' attempt_clock='.time().','.
< 					' attempt_ip='.zbx_dbstr($ip).
< 				' WHERE userid='.zbx_dbstr($userInfo['userid'])
< 			);
---
> 	 * @return keycloak AUTH page		session id
>      **/
>     public function keycloakWebLogin() {
>         if (PHP_SESSION_ACTIVE !== session_status()) {
>             session_start();
>         }
>         $scheme = $_SERVER['REQUEST_SCHEME'];
>         $address = $_SERVER['SERVER_NAME'];
>         $port = $_SERVER['SERVER_PORT'];
>         $prefix = $_SERVER['CONTEXT_PREFIX'];
>         #----------
>         $resourceUri =  sprintf("%s://%s:%s%s/index.php",$scheme,$address,$port,$prefix);
>         $callbackUri =  sprintf("%s://%s:%s%s/index_callback.php",$scheme,$address,$port,$prefix);
>         $config=select_config();
>         $requestScope = $config['keycloak_client_scope'];
>         $client = CWebUser::getOAuth2client();
>         session_write_close();
>         http_response_code(302);
>         header(sprintf('Location: %s',$client->getAuthorizeUri($requestScope, $callbackUri)));
>     }
> 
>     public function keycloakDAGLogin($user) {
>         if (PHP_SESSION_ACTIVE !== session_status()) {
>             session_start();
>         }
>         $config=select_config();
>         $requestScope = $config['keycloak_client_scope'];
>         $client = CWebUser::getOAuth2client();
>         $res = $client->DAGloginKeycloakServer($user);
>         session_write_close();
>         return $res;
>     }
1155,1165d1112
< 			add_audit_details(AUDIT_ACTION_LOGIN, AUDIT_RESOURCE_USER, $userInfo['userid'], '',
< 				_s('Login failed "%s".', $name), $userInfo['userid']
< 			);
< 			self::exception(ZBX_API_ERROR_PARAMETERS, $e->getMessage());
< 		}
< 
< 		// start session
< 		$sessionid = md5(microtime().$password.$name.mt_rand());
< 		DBexecute('INSERT INTO sessions (sessionid,userid,lastaccess,status)'.
< 			' VALUES ('.zbx_dbstr($sessionid).','.zbx_dbstr($userInfo['userid']).','.time().','.ZBX_SESSION_ACTIVE.')'
< 		);
1167,1170d1113
< 		$userData = $this->_getUserData($userInfo['userid']);
< 		$userData['sessionid'] = $sessionid;
< 		$userData['gui_access'] = $guiAccess;
< 		$userData['userid'] = $userInfo['userid'];
1172,1174c1115,1267
< 		if ($userInfo['attempt_failed']) {
< 			DBexecute('UPDATE users SET attempt_failed=0 WHERE userid='.zbx_dbstr($userInfo['userid']));
< 		}
---
> 	public function login($user) {
> 		$name = $user['user'];
> 		$password = md5($user['password']);
>         
>         //add the following ZBX_AUTH_KEYCLOAK Branch for jsonRpc login...
>         $config = select_config();
>         if ($config['authentication_type'] == ZBX_AUTH_KEYCLOAK){
>             $result = $this->keycloakDAGLogin($user);
>             if (false != $result || !empty($result)) {
>                 $userInfo = DBfetch(DBselect(
>                     'SELECT u.userid,u.attempt_failed,u.attempt_clock,u.attempt_ip'.
>                     ' FROM users u'.
>                     ' WHERE u.alias='.zbx_dbstr($name)
>                 ));
>                 if (!$userInfo) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _('Login name or password is incorrect.'));
>                 }
>                 // check system permissions
>                 if (!check_perm2system($userInfo['userid'])) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
>                 }
>                 $dbAccess = DBfetch(DBselect(
>                     'SELECT MAX(g.gui_access) AS gui_access'.
>                     ' FROM usrgrp g,users_groups ug'.
>                     ' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
>                         ' AND g.usrgrpid=ug.usrgrpid'
>                 ));
> 
>                 if (zbx_empty($dbAccess['gui_access'])) {
>                     $guiAccess = GROUP_GUI_ACCESS_SYSTEM;
>                 }else{
>                     $guiAccess = $dbAccess['gui_access'];
>                 }
>                 $userData = $this->_getUserData($userInfo['userid']);
>                 $userData['sessionid'] = $result;
>                 $userData['gui_access'] = $guiAccess;
>                 $userData['userid'] = $userInfo['userid'];
>                 CWebUser::$data = self::$userData = $userData;
>                 return isset($user['userData']) ? $userData : $userData['sessionid'];
>             }else{
>                 self::exception(ZBX_API_ERROR_PARAMETERS, _('Login name or password is incorrect.'));
>             }            
>         }else{
>             $userInfo = DBfetch(DBselect(
>                 'SELECT u.userid,u.attempt_failed,u.attempt_clock,u.attempt_ip'.
>                 ' FROM users u'.
>                 ' WHERE u.alias='.zbx_dbstr($name)
>             ));
>             if (!$userInfo) {
>                 self::exception(ZBX_API_ERROR_PARAMETERS, _('Login name or password is incorrect.'));
>             }
> 
>             // check if user is blocked
>             if ($userInfo['attempt_failed'] >= ZBX_LOGIN_ATTEMPTS) {
>                 if ((time() - $userInfo['attempt_clock']) < ZBX_LOGIN_BLOCK) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _s('Account is blocked for %s seconds', (ZBX_LOGIN_BLOCK - (time() - $userInfo['attempt_clock']))));
>                 }
> 
>                 DBexecute('UPDATE users SET attempt_clock='.time().' WHERE alias='.zbx_dbstr($name));
>             }
> 
>             // check system permissions
>             if (!check_perm2system($userInfo['userid'])) {
>                 self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
>             }
> 
>             $dbAccess = DBfetch(DBselect(
>                 'SELECT MAX(g.gui_access) AS gui_access'.
>                 ' FROM usrgrp g,users_groups ug'.
>                 ' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
>                     ' AND g.usrgrpid=ug.usrgrpid'
>             ));
> 
>             if (zbx_empty($dbAccess['gui_access'])) {
>                 $guiAccess = GROUP_GUI_ACCESS_SYSTEM;
>             }
>             else {
>                 $guiAccess = $dbAccess['gui_access'];
>             }
> 
>             $config = select_config();
>             $authType = $config['authentication_type'];
> 
>             switch ($guiAccess) {
>                 case GROUP_GUI_ACCESS_INTERNAL:
>                     $authType = ($authType == ZBX_AUTH_HTTP) ? ZBX_AUTH_HTTP : ZBX_AUTH_INTERNAL;
>                     break;
>                 case GROUP_GUI_ACCESS_DISABLED:
>                     /* fall through */
>                 case GROUP_GUI_ACCESS_SYSTEM:
>                     /* fall through */
>             }
> 
>             if ($authType == ZBX_AUTH_HTTP) {
>                 // if PHP_AUTH_USER is not set, it means that HTTP authentication is not enabled
>                 if (!isset($_SERVER['PHP_AUTH_USER'])) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _('Cannot login.'));
>                 }
>                 // check if the user name used when calling the API matches the one used for HTTP authentication
>                 elseif ($name !== $_SERVER['PHP_AUTH_USER']) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS,
>                         _s('Login name "%1$s" does not match the name "%2$s" used to pass HTTP authentication.',
>                             $name, $_SERVER['PHP_AUTH_USER']
>                         )
>                     );
>                 }
>             }
> 
>             try {
>                 switch ($authType) {
>                     case ZBX_AUTH_LDAP:
>                         $this->ldapLogin($user);
>                         break;
>                     case ZBX_AUTH_INTERNAL:
>                         $this->dbLogin($user);
>                         break;
>                     case ZBX_AUTH_HTTP:
>                 }
>             }
>             catch (APIException $e) {
>                 $ip = (isset($_SERVER['HTTP_X_FORWARDED_FOR']) && !empty($_SERVER['HTTP_X_FORWARDED_FOR']))
>                         ? $_SERVER['HTTP_X_FORWARDED_FOR']
>                         : $_SERVER['REMOTE_ADDR'];
>                 $userInfo['attempt_failed']++;
> 
>                 DBexecute(
>                     'UPDATE users'.
>                     ' SET attempt_failed='.zbx_dbstr($userInfo['attempt_failed']).','.
>                         ' attempt_clock='.time().','.
>                         ' attempt_ip='.zbx_dbstr($ip).
>                     ' WHERE userid='.zbx_dbstr($userInfo['userid'])
>                 );
> 
>                 add_audit_details(AUDIT_ACTION_LOGIN, AUDIT_RESOURCE_USER, $userInfo['userid'], '',
>                     _s('Login failed "%s".', $name), $userInfo['userid']
>                 );
>                 self::exception(ZBX_API_ERROR_PARAMETERS, $e->getMessage());
>             }
> 
>             // start session
>             $sessionid = md5(microtime().$password.$name.mt_rand());
>             DBexecute('INSERT INTO sessions (sessionid,userid,lastaccess,status)'.
>                 ' VALUES ('.zbx_dbstr($sessionid).','.zbx_dbstr($userInfo['userid']).','.time().','.ZBX_SESSION_ACTIVE.')'
>             );
> 
>             $userData = $this->_getUserData($userInfo['userid']);
>             $userData['sessionid'] = $sessionid;
>             $userData['gui_access'] = $guiAccess;
>             $userData['userid'] = $userInfo['userid'];
> 
>             if ($userInfo['attempt_failed']) {
>                 DBexecute('UPDATE users SET attempt_failed=0 WHERE userid='.zbx_dbstr($userInfo['userid']));
>             }
1176c1269
< 		CWebUser::$data = self::$userData = $userData;
---
>             CWebUser::$data = self::$userData = $userData;
1178c1271,1272
< 		return isset($user['userData']) ? $userData : $userData['sessionid'];
---
>             return isset($user['userData']) ? $userData : $userData['sessionid'];
>         }
1188,1189c1282,1456
< 	public function checkAuthentication(array $sessionid) {
< 		$sessionid = reset($sessionid);
---
>     public function checkAuthentication(array $sessionid) {
>         $config=select_config();
>         if ($config['authentication_type'] == ZBX_AUTH_KEYCLOAK) {
>             $sessionid = reset($sessionid);
>             if (!is_null(self::$userData)) {
>                 return self::$userData;
>             }
>             $time = time();  //millisecond since 1970.01.01
>             
>             //1.GET TokenData OBJ based on sessionid.
>                 //if errors happend with the token object, do the following things
>                 //a.Delete the cookie on browser side.
>                 //b.Delete the session table on zbx side.
>                 //c.Return the empty Array...
>             if (PHP_SESSION_ACTIVE !== session_status()) {
>                 session_start();
>             }
>             $client = CWebUser::getOAuth2client();
>             try {
>                 $TokenObj = $client->getAccessToken($sessionid);
>                 if (false == $TokenObj) {
>                     //Token is not found based on cookie value,do the following things;
>                     setcookie('zbx_sessionid',null,-99999);
>                     unset($_COOKIE['zbx_sessionid']);
>                     DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                     return self::$userData = [];
>                 }
>             }
>             catch(Exception $e){
>                     setcookie('zbx_sessionid',null,-99999);
>                     unset($_COOKIE['zbx_sessionid']);
>                     DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                     return self::$userData = [];
>             }
>             $dateTime = new DateTime();  //full date ...
>             if (true == $TokenObj->isExpired($dateTime)) {
>                 if (null === $TokenObj->getRefreshToken()) {
>                     setcookie('zbx_sessionid',null,-99999);
>                     unset($_COOKIE['zbx_sessionid']);
>                     DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                     return self::$userData = [];
>                 }
>                 try{
>                     $TokenObj= $client->refreshAccessToken($TokenObj,$sessionid);
>                     if (false == $TokenObj) {
>                         setcookie('zbx_sessionid',null,-99999);
>                         unset($_COOKIE['zbx_sessionid']);
>                         DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                         return self::$userData = [];
>                     }
>                 }catch(Exception $e){
>                         setcookie('zbx_sessionid',null,-99999);
>                         unset($_COOKIE['zbx_sessionid']);
>                         DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                         return self::$userData = [];
>                 } 
>             }
>             session_write_close();
>             DBexecute('UPDATE users SET autologout='.zbx_dbstr($TokenObj->getRefreshExpiresIn()).' WHERE alias='.zbx_dbstr($TokenObj->getName())); 
>             //2.GET userinfo based on sessionid
>             $userInfo = DBfetch(DBselect(
>                 'SELECT u.userid,u.autologout,s.lastaccess'.
>                 ' FROM sessions s,users u'.
>                 ' WHERE s.sessionid='.zbx_dbstr($sessionid).
>                         ' AND s.status='.ZBX_SESSION_ACTIVE.
>                         ' AND s.userid=u.userid'.
>                         ' AND (s.lastaccess+u.autologout>'.$time.' OR u.autologout=0)'
>                     ));
>             if (!$userInfo) {
>                 setcookie('zbx_sessionid',null,-99999);
>                 unset($_COOKIE['zbx_sessionid']);
>                 DBexecute('DELETE FROM sessions WHERE sessionid='.zbx_dbstr($sessionid));
>                 return self::$userData = [];
>             }
>             //update session's time to latest which bind to acccess-token.
>             //Though the session have no affect on the authentication,but update it for the latent session-mechinism of zabbix.
>             if ($time != $userInfo['lastaccess']) {
>                 if (!check_perm2system($userInfo['userid'])) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
>                 }
> 
>                 if ($userInfo['autologout'] > 0) {
>                     DBexecute(
>                         'DELETE FROM sessions'.
>                         ' WHERE userid='.zbx_dbstr($userInfo['userid']).
>                             ' AND lastaccess<'.(time() - $userInfo['autologout'])
>                     );
>                 }
>                 DBexecute(
>                     'UPDATE sessions'.
>                     ' SET lastaccess='.time().
>                     ' WHERE userid='.zbx_dbstr($userInfo['userid']).
>                         ' AND sessionid='.zbx_dbstr($sessionid)
>                 );
>             }
> 
>             $dbAccess = DBfetch(DBselect(
>                 'SELECT MAX(g.gui_access) AS gui_access'.
>                 ' FROM usrgrp g,users_groups ug'.
>                 ' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
>                 ' AND g.usrgrpid=ug.usrgrpid'
>             ));
> 
>             if (!zbx_empty($dbAccess['gui_access'])) {
>                 $guiAccess = $dbAccess['gui_access'];
>             }else{
>                 $guiAccess = GROUP_GUI_ACCESS_SYSTEM;
>             }
>             $userData = $this->_getUserData($userInfo['userid']);
>             $userData['sessionid'] = $sessionid;
>             $userData['gui_access'] = $guiAccess;
>             CWebUser::$data = self::$userData = $userData;
>             return $userData;
>         }else{
>             $sessionid = reset($sessionid);
> 
>             // access DB only once per page load
>             if (!is_null(self::$userData)) {
>                 return self::$userData;
>             }
> 
>             $time = time();
> 
>             $userInfo = DBfetch(DBselect(
>                 'SELECT u.userid,u.autologout,s.lastaccess'.
>                 ' FROM sessions s,users u'.
>                 ' WHERE s.sessionid='.zbx_dbstr($sessionid).
>                     ' AND s.status='.ZBX_SESSION_ACTIVE.
>                     ' AND s.userid=u.userid'.
>                     ' AND (s.lastaccess+u.autologout>'.$time.' OR u.autologout=0)'
>             ));
> 
>             if (!$userInfo) {
>                 self::exception(ZBX_API_ERROR_PARAMETERS, _('Session terminated, re-login, please.'));
>             }
> 
>             // don't check permissions on the same second
>             if ($time != $userInfo['lastaccess']) {
>                 if (!check_perm2system($userInfo['userid'])) {
>                     self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
>                 }
> 
>                 if ($userInfo['autologout'] > 0) {
>                     DBexecute(
>                         'DELETE FROM sessions'.
>                         ' WHERE userid='.zbx_dbstr($userInfo['userid']).
>                             ' AND lastaccess<'.(time() - $userInfo['autologout'])
>                     );
>                 }
> 
>                 DBexecute(
>                     'UPDATE sessions'.
>                     ' SET lastaccess='.time().
>                     ' WHERE userid='.zbx_dbstr($userInfo['userid']).
>                         ' AND sessionid='.zbx_dbstr($sessionid)
>                 );
>             }
> 
>             $dbAccess = DBfetch(DBselect(
>                 'SELECT MAX(g.gui_access) AS gui_access'.
>                 ' FROM usrgrp g,users_groups ug'.
>                 ' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
>                     ' AND g.usrgrpid=ug.usrgrpid'
>             ));
> 
>             if (!zbx_empty($dbAccess['gui_access'])) {
>                 $guiAccess = $dbAccess['gui_access'];
>             }
>             else {
>                 $guiAccess = GROUP_GUI_ACCESS_SYSTEM;
>             }
> 
>             $userData = $this->_getUserData($userInfo['userid']);
>             $userData['sessionid'] = $sessionid;
>             $userData['gui_access'] = $guiAccess;
1191,1215c1458
< 		// access DB only once per page load
< 		if (!is_null(self::$userData)) {
< 			return self::$userData;
< 		}
< 
< 		$time = time();
< 
< 		$userInfo = DBfetch(DBselect(
< 			'SELECT u.userid,u.autologout,s.lastaccess'.
< 			' FROM sessions s,users u'.
< 			' WHERE s.sessionid='.zbx_dbstr($sessionid).
< 				' AND s.status='.ZBX_SESSION_ACTIVE.
< 				' AND s.userid=u.userid'.
< 				' AND (s.lastaccess+u.autologout>'.$time.' OR u.autologout=0)'
< 		));
< 
< 		if (!$userInfo) {
< 			self::exception(ZBX_API_ERROR_PARAMETERS, _('Session terminated, re-login, please.'));
< 		}
< 
< 		// don't check permissions on the same second
< 		if ($time != $userInfo['lastaccess']) {
< 			if (!check_perm2system($userInfo['userid'])) {
< 				self::exception(ZBX_API_ERROR_PARAMETERS, _('No permissions for system access.'));
< 			}
---
>             CWebUser::$data = self::$userData = $userData;
1217,1253c1460,1461
< 			if ($userInfo['autologout'] > 0) {
< 				DBexecute(
< 					'DELETE FROM sessions'.
< 					' WHERE userid='.zbx_dbstr($userInfo['userid']).
< 						' AND lastaccess<'.(time() - $userInfo['autologout'])
< 				);
< 			}
< 
< 			DBexecute(
< 				'UPDATE sessions'.
< 				' SET lastaccess='.time().
< 				' WHERE userid='.zbx_dbstr($userInfo['userid']).
< 					' AND sessionid='.zbx_dbstr($sessionid)
< 			);
< 		}
< 
< 		$dbAccess = DBfetch(DBselect(
< 			'SELECT MAX(g.gui_access) AS gui_access'.
< 			' FROM usrgrp g,users_groups ug'.
< 			' WHERE ug.userid='.zbx_dbstr($userInfo['userid']).
< 				' AND g.usrgrpid=ug.usrgrpid'
< 		));
< 
< 		if (!zbx_empty($dbAccess['gui_access'])) {
< 			$guiAccess = $dbAccess['gui_access'];
< 		}
< 		else {
< 			$guiAccess = GROUP_GUI_ACCESS_SYSTEM;
< 		}
< 
< 		$userData = $this->_getUserData($userInfo['userid']);
< 		$userData['sessionid'] = $sessionid;
< 		$userData['gui_access'] = $guiAccess;
< 
< 		CWebUser::$data = self::$userData = $userData;
< 
< 		return $userData;
---
>             return $userData;
>         }
1275,1276c1483
< 
< 		return $userData;
---
>         return $userData;
